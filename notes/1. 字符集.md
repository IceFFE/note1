# 字符集

## 通用字符集

1. ASCI 推出 ASCII

2. 中国为了支持中文，对 ASCII 扩充，产生了 GB2312 编码，可以表示 6000 多个常用汉字，区分全角半角。

3. 中国为支持繁体和各种字符等，产生了 GBK 编码，它包括了 GB2312 中的编码，同时扩充了很多。

4. 中国为了支持各个民族的语言，继续把 GBK 编码扩充为 GB18030 编码。

5. 每个国家都像中国一样把自己的语言编码，于是出现了各种各样的编码。

6. 1991 年 10 月 发布 Unicode v1.0.0，规定了字符对应的代码点(Code Point)。

    1. 0x000000-0x10FFFF: 共 17 个平面，每个平面 65536

7. UNICODE 在网络传输中，出现了传输编码方案，如 UTF-8、UTF-16 和 UTF-32 等

## UNICODE

1. 17 个平面（1 个基本 + 16 个补充），每个面 0xFFFF(65535) 个空间

    ```txt
      0x000000 - 0x00FFFF 基本多文种平面 BMP
      0x010000 - 0x01FFFF 多文种补充平面 SMP
      0x020000 - 0x02FFFF 表意文字补充平面 SIP
      ......
      0x0F0000 - 0x0FFFFF 保留作为私人使用区（A 区）PUA-A
      0x100000 - 0x10FFFF 保留作为私人使用区（B 区）PUA-B
    ```

## 传输方案

### UTF-8

1. 直接计算码点

    ```txt
    0x000000 - 0x00007F: 0xxxxxxx
    0x000080 - 0x0007FF: 110xxxxx 10xxxxxx
    0x000800 - 0x00FFFF: 1110xxxx 10xxxxxx 10xxxxxx
    0x010000 - 0x10FFFF: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
    ```

### UTF-16

1. 2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。

2. 基本面的用 2 个字节

    1. 0x0000 - 0xFFFF

3. 辅助面的用 4 个字节

    1. 在基本平面的 0xD800 - 0xDFFF 强制空位

        ```txt
        0xD800: 0b1101100000000000
        0xDBFF: 0b1101101111111111
        0xDC00: 0b1101110000000000
        0xDFFF: 0b1101111111111111
        ```

    2. 16 个辅面，从 U+10000 到 U+10FFFF，共 0xFFFFF 个码位，2(20)

    3. 前 10 位映射在 U+D800 到 U+DBFF，称为高位（H）

    4. 后 10 位映射在 U+DC00 到 U+DFFF，称为低位（L）

4. "𠮷" Unicode 码点为 0x20BB7(134071)

    1. 该码点显然超出了基本平面的范围（0x0000 - 0xFFFF），因此需要使用四个字节表示。
    2. 首先用 0x20BB7 - 0x10000 计算出超出的部分 0x10BB7
    3. 然后将其用 20 个二进制位表示，结果为 0001 0000 1011 1011 0111。
    4. 接着，将前 10 位映射到 U+D800 到 U+DBFF 之间，后 10 位映射到 U+DC00 到 U+DFFF 即可。
    5. U+D800 对应的二进制数为 1101100000000000，直接填充后面的 10 个二进制位，得到 1101100001000010，高位为 0xD842。
    6. U+DC00 对应的二进制为 1101110000000000，加上后 10 位，得到 1101111110110111 低位为 0xDFB7。
    7. 因此得出汉字"𠮷"的 UTF-16 编码为 0xD842 0xDFB7。常用"\uD842\uDFB7"表示。

### UTF-32

1. 直接四个字节显示: 0x00000000 - 0x0010FFFF

## 字节顺序标记-BOM(byte-order mark)

1. 字符集格式

    1. UTF-8 EF BB FE
    2. UTF-16LE FF FE
    3. UTF-16HE FE FF
    4. UTF-32BE 00 00 FE FF
    5. UTF-32LE FF FE 00 00

2. endian

    1. 大端序-be(Big-Endian)

        ```txt
        n6 [....]
        n5 [....]
        n4 [0x10] ──────────┐
        n3 [0x32] ────────┐ │
        n2 [0x54] ──────┐ │ │
        n1 [0x76] ────┐ │ │ │
                    0x76543210
        ```

    2. 小端序-le(Little-Endian)

        ```txt
        n6 [....]
        n5 [....]   0x76543210
        n4 [0x76] ────┘ │ │ │
        n3 [0x54] ──────┘ │ │
        n2 [0x32] ────────┘ │
        n1 [0x10] ──────────┘
        ```

3. "𠮷"

    1. UTF-16be: D8 42 DF B7

    2. UTF-16le: 42 D8 B7 DF

4. 0x76543210 在 BE LE 上内存机制

    ```txt
    // 大端序: 高位开始低位结束
    地址    n1          n2          n3          n4          n5
    byte    [0x76]      [0x54]      [0x32]      [0x10]      [....]
    bit     0111 0110   0101 0100   0011 0010   0001 0000

    // 小端序: 低位开始高位结束
    地址    n1          n2          n3          n4          n5
    byte    [0x10]      [0x32]      [0x54]      [0x76]      [....]
    bit     0000 1000   0100 1100   0010 1010   0110 1110
    ```

5. 内存读取单位

    1. bit => 最小单位
    2. byte => 1byte = 8bit (内存读写最小单位)
    3. sector => 1sector = 512byte
    4. cluster => 1cluster = 2ⁿsector (最小文件单位)
